# 分布式系统知识体系大纲

## 第一部分：分布式系统基础理论

### 1. CAP 理论 ⭐⭐⭐⭐⭐

#### 1.1 CAP 定义
- **Consistency（一致性）**
  - 所有节点在同一时刻看到的数据是一致的
  - 等同于所有节点访问同一份最新的数据副本
  - 强一致性 vs 弱一致性 vs 最终一致性
- **Availability（可用性）**
  - 每次请求都能获得非错误响应
  - 不保证获取的数据是最新的
  - 通常用可用率衡量（如 99.99%）
- **Partition Tolerance（分区容错性）**
  - 系统在网络分区的情况下仍能继续工作
  - 分区：网络故障导致节点间无法通信
  - 分布式系统必须容忍分区

#### 1.2 CAP 权衡
- **CA（一致性 + 可用性）**
  - 单机数据库（MySQL、PostgreSQL）
  - 无法容忍网络分区
  - 不适合分布式场景
- **CP（一致性 + 分区容错）**
  - ZooKeeper、etcd、HBase
  - 网络分区时牺牲可用性
  - 适用于强一致性要求的场景
- **AP（可用性 + 分区容错）**
  - Cassandra、DynamoDB、Eureka
  - 网络分区时牺牲一致性
  - 适用于高可用要求的场景

#### 1.3 常见误区
- 不是非此即彼的选择，而是程度问题
- 实际系统往往在 CP 和 AP 之间权衡
- 可以针对不同数据采用不同策略

### 2. BASE 理论

#### 2.1 BASE 定义
- **Basically Available（基本可用）**
  - 分布式系统出现故障时，允许损失部分可用性
  - 响应时间上的损失（如延迟增加）
  - 功能上的损失（如降级、限流）
- **Soft State（软状态）**
  - 允许系统中的数据存在中间状态
  - 该状态不影响系统整体可用性
  - 即允许不同节点间的数据同步存在延迟
- **Eventually Consistent（最终一致性）**
  - 系统中所有数据副本经过一定时间后最终能够达到一致状态
  - 不需要实时保证强一致性
  - 允许一定时间窗口内的数据不一致

#### 2.2 BASE vs ACID
- ACID：强一致性模型（传统数据库）
- BASE：弱一致性模型（分布式系统）
- BASE 是对 CAP 中 AP 方案的延伸
- 通过牺牲强一致性来获得高可用性

### 3. 分布式一致性级别

#### 3.1 强一致性（Strong Consistency）
- 任何时刻所有节点数据完全一致
- 写入后立即可见
- 实现成本高，性能差
- 典型实现：Paxos、Raft

#### 3.2 弱一致性（Weak Consistency）
- 不保证后续访问能返回最新值
- 尽最大努力使数据趋于一致
- 系统不保证多久之后数据能够达到一致

#### 3.3 最终一致性（Eventual Consistency）
- 弱一致性的特殊形式
- 保证在没有新更新的条件下，最终所有访问都能看到最新值
- 具体变种：
  - 因果一致性：有因果关系的操作顺序一致
  - 读己之所写：写入后自己能立即读到
  - 会话一致性：同一会话内保证一致性
  - 单调读一致性：读到的数据不会比之前读到的旧
  - 单调写一致性：写操作顺序保证

## 第二部分：分布式一致性算法 ⭐⭐⭐⭐⭐ 重点

### 4. Paxos 算法

#### 4.1 Paxos 核心概念
- **角色划分**
  - Proposer（提议者）：提出提案
  - Acceptor（接受者）：投票决定是否接受提案
  - Learner（学习者）：学习被选定的提案
- **提案结构**
  - 提案编号（Proposal ID）：全局唯一且递增
  - 提案值（Value）：实际要达成一致的值

#### 4.2 Basic Paxos 流程
**阶段一：Prepare 阶段**
- Proposer 选择提案编号 n，向多数派 Acceptor 发送 Prepare(n)
- Acceptor 收到 Prepare(n)：
  - 如果 n 大于已承诺的编号，则承诺不再接受编号小于 n 的提案
  - 返回已接受的最大编号提案（如果有）

**阶段二：Accept 阶段**
- Proposer 收到多数派响应后，发送 Accept(n, v)
  - v 为收到的最大编号提案的值，若无则为自己的值
- Acceptor 收到 Accept(n, v)：
  - 如果 n 不小于已承诺的编号，则接受该提案

#### 4.3 Multi-Paxos
- Basic Paxos 每次决策需要两轮通信
- Multi-Paxos 优化：
  - 选举一个 Leader
  - Leader 可以跳过 Prepare 阶段
  - 减少通信轮次，提高效率

### 5. Raft 算法 ⭐⭐⭐⭐⭐

#### 5.1 Raft 核心概念
- **角色**
  - Leader（领导者）：处理所有客户端请求
  - Follower（跟随者）：被动接收请求
  - Candidate（候选人）：用于选举 Leader
- **任期（Term）**
  - 逻辑时钟，单调递增
  - 每个任期最多一个 Leader
  - 选举超时触发新任期

#### 5.2 Leader 选举
**选举触发条件**：
- Follower 在选举超时内未收到 Leader 心跳
- 转换为 Candidate，任期加 1

**选举流程**：
1. Candidate 向所有节点发送投票请求
2. 每个节点在一个任期内只能投一票
3. 获得多数票的 Candidate 成为 Leader
4. 选举失败则增加任期，重新选举

**选举约束**：
- 日志更完整的节点优先当选
- 避免日志回滚

#### 5.3 日志复制
**复制流程**：
1. Leader 接收客户端请求，追加到本地日志
2. 并行向所有 Follower 发送 AppendEntries
3. 收到多数派确认后，提交日志并应用到状态机
4. 通知 Follower 提交日志

**日志一致性保证**：
- Leader Completeness：已提交的日志不会丢失
- State Machine Safety：不同节点在相同索引的日志项相同

#### 5.4 安全性保证
- 选举安全性：每个任期最多一个 Leader
- Leader 只追加日志：Leader 不会覆盖或删除日志
- 日志匹配性：相同索引和任期的日志项一定相同
- Leader 完整性：已提交的日志一定在未来的 Leader 中
- 状态机安全性：节点应用相同日志到状态机后状态一致

#### 5.5 Raft vs Paxos
| 特性 | Raft | Paxos |
|------|------|-------|
| 可理解性 | 易于理解 | 复杂难懂 |
| Leader | 强 Leader | 无 Leader / 弱 Leader |
| 日志 | 日志必须连续 | 日志可以有空洞 |
| 工程实现 | 容易 | 困难 |

### 6. ZooKeeper ZAB 协议

#### 6.1 ZAB 协议概述
- ZooKeeper Atomic Broadcast
- 专为 ZooKeeper 设计的一致性协议
- 基于 Paxos 改进

#### 6.2 ZAB 核心机制
- **崩溃恢复**：Leader 选举和数据同步
- **消息广播**：类似两阶段提交
- **ZXID**：事务 ID，64 位（32 位 epoch + 32 位计数器）

#### 6.3 ZAB 四种状态
- Looking：选举状态
- Following：跟随者状态
- Leading：领导者状态
- Observing：观察者状态（不参与投票）

## 第三部分：分布式存储

### 7. 分布式存储基础

#### 7.1 数据分片（Sharding）
- **哈希分片**
  - 对 key 计算哈希值，取模得到分片
  - 优点：分布均匀
  - 缺点：扩缩容需要数据迁移
- **一致性哈希**
  - 环形哈希空间
  - 虚拟节点解决数据倾斜
  - 扩缩容只影响相邻节点
- **范围分片**
  - 按 key 的范围分片
  - 优点：支持范围查询
  - 缺点：可能数据倾斜

#### 7.2 数据副本
- **副本作用**
  - 提高可用性
  - 提高读性能
  - 容灾备份
- **副本一致性**
  - 主从复制：一个主节点，多个从节点
  - 多主复制：多个主节点，冲突解决复杂
  - 无主复制：Quorum 机制

#### 7.3 Quorum 机制
- N：副本数
- W：写成功需要的确认数
- R：读需要的副本数
- 强一致性：W + R > N
- 最终一致性：W + R <= N

### 8. Cassandra

#### 8.1 架构特点
- 完全去中心化，无单点故障
- P2P 架构，节点对等
- AP 系统：最终一致性

#### 8.2 核心机制
- **一致性哈希**：数据分布
- **Gossip 协议**：节点通信
- **Hinted Handoff**：临时存储写入
- **Merkle Tree**：数据同步和修复
- **读写路径**：
  - 写：内存表（MemTable）+ 提交日志（CommitLog）
  - 读：MemTable + SSTable，使用 Bloom Filter 优化

### 9. HBase

#### 9.1 架构设计
- 基于 Hadoop 的分布式列式数据库
- CP 系统：强一致性
- 适合大规模稀疏数据存储

#### 9.2 核心组件
- **HMaster**：管理节点，负责 Region 分配
- **RegionServer**：数据节点，管理 Region
- **Region**：表的一个分片
- **ZooKeeper**：协调服务，存储元数据

#### 9.3 存储模型
- **LSM Tree**：Log-Structured Merge Tree
  - MemStore：内存写缓存
  - HFile：磁盘 SSTable
  - Compaction：合并文件
- **Row Key 设计**：影响性能的关键
  - 避免热点
  - 散列前缀
  - 预分区

## 第四部分：服务治理与微服务

### 10. 服务注册与发现

#### 10.1 注册中心作用
- 服务注册：服务启动时注册到注册中心
- 服务发现：客户端从注册中心获取服务列表
- 健康检查：检测服务是否可用
- 负载均衡：选择服务实例

#### 10.2 常见注册中心
- **ZooKeeper**
  - CP 系统，强一致性
  - 集群模式，ZAB 协议
  - 适合对一致性要求高的场景
- **Eureka**
  - AP 系统，最终一致性
  - 自我保护机制
  - 适合云环境，容忍网络分区
- **Consul**
  - CP/AP 可配置
  - 支持多数据中心
  - 内置健康检查和 KV 存储
- **Nacos**
  - 阿里开源，支持配置管理
  - CP/AP 双模式
  - 动态配置更新

### 11. 服务间通信

#### 11.1 RPC 框架
- **Dubbo**
  - 阿里开源，成熟稳定
  - 支持多种协议和序列化
  - 服务治理功能丰富
- **gRPC**
  - Google 开源，基于 HTTP/2
  - Protobuf 序列化
  - 跨语言支持好

#### 11.2 负载均衡策略
- 随机（Random）
- 轮询（Round Robin）
- 加权轮询（Weighted Round Robin）
- 最少活跃调用（Least Active）
- 一致性哈希（Consistent Hash）

### 12. 微服务架构核心问题 ⭐⭐⭐⭐⭐

#### 12.1 服务拆分
- **拆分原则**
  - 单一职责
  - 业务边界清晰
  - 高内聚低耦合
- **拆分粒度**
  - 不宜过细（增加复杂度）
  - 不宜过粗（失去微服务优势）

#### 12.2 分布式事务
- **两阶段提交（2PC）**
  - 强一致性
  - 性能差，阻塞
- **TCC（Try-Confirm-Cancel）**
  - 业务侵入性强
  - 性能较好
- **Saga**
  - 长事务场景
  - 最终一致性
- **本地消息表**
  - 最终一致性
  - 实现相对简单

#### 12.3 服务熔断与降级
- **熔断器（Circuit Breaker）**
  - 三种状态：关闭、开启、半开
  - 快速失败，避免雪崩
  - Hystrix、Sentinel、Resilience4j
- **降级策略**
  - 返回默认值
  - 返回缓存数据
  - 快速失败

#### 12.4 限流
- **限流算法**
  - 固定窗口计数器
  - 滑动窗口计数器
  - 漏桶算法（Leaky Bucket）
  - 令牌桶算法（Token Bucket）
- **限流层级**
  - 接入层限流（Nginx）
  - 服务层限流（Sentinel）
  - 数据库限流（连接池）

#### 12.5 链路追踪
- **核心概念**
  - TraceID：全局唯一 ID
  - SpanID：单次调用 ID
  - 父子关系
- **常见框架**
  - Zipkin
  - SkyWalking
  - Jaeger

#### 12.6 配置中心
- **配置管理需求**
  - 集中管理
  - 动态更新
  - 版本管理
  - 权限控制
- **常见方案**
  - Apollo（携程）
  - Nacos（阿里）
  - Spring Cloud Config

### 13. API 网关

#### 13.1 网关职责
- 路由转发
- 统一认证鉴权
- 限流熔断
- 日志监控
- 协议转换

#### 13.2 常见网关
- **Nginx + Lua**
  - 性能高
  - 配置灵活
- **Kong**
  - 基于 OpenResty
  - 插件丰富
- **Spring Cloud Gateway**
  - 异步非阻塞
  - 与 Spring 生态集成好
- **Zuul**
  - Netflix 开源
  - 同步阻塞（Zuul 1.x）

## 面试高频考点

### 必须掌握（⭐⭐⭐⭐⭐）

1. **CAP 理论**
   - 三者含义和权衡
   - 常见系统的 CAP 选择
   - 为什么分布式系统无法同时满足 CAP

2. **Raft 算法**
   - Leader 选举流程
   - 日志复制流程
   - 如何保证一致性和可用性
   - Raft vs Paxos

3. **分布式事务**
   - 2PC、TCC、Saga 的区别
   - 如何选择分布式事务方案
   - 本地消息表实现原理

4. **服务注册与发现**
   - ZooKeeper vs Eureka
   - CP vs AP 的选择
   - 服务发现的实现原理

5. **微服务限流熔断**
   - 熔断器的三种状态
   - 限流算法及其区别
   - 如何设计限流方案

### 深入理解（⭐⭐⭐⭐）

6. **一致性哈希**
   - 解决的问题
   - 虚拟节点的作用
   - 实现原理

7. **Quorum 机制**
   - N、W、R 的含义
   - 如何保证一致性
   - Dynamo、Cassandra 的应用

8. **ZAB 协议**
   - ZAB vs Raft
   - 崩溃恢复和消息广播
   - ZXID 的作用

9. **分布式存储**
   - HBase vs Cassandra
   - LSM Tree 原理
   - 数据分片策略

10. **服务治理**
    - Dubbo 架构和特性
    - 负载均衡策略
    - 链路追踪原理

### 实战能力（⭐⭐⭐⭐⭐）

- 设计一个分布式锁
- 设计一个 ID 生成器（雪花算法）
- 设计一个微服务架构
- 解决分布式事务一致性问题
- 设计一个高可用的注册中心
- 分析一个服务雪崩的场景并给出解决方案

## 学习路径

### 第一阶段：分布式理论（2-3 周）
1. CAP 和 BASE 理论
2. 一致性级别
3. 数据分片和副本

### 第二阶段：一致性算法（3-4 周）⭐ 重点
1. Paxos 算法
2. Raft 算法（重点）
3. ZAB 协议
4. 动手实现 Raft

### 第三阶段：分布式存储（2-3 周）
1. 一致性哈希
2. Quorum 机制
3. Cassandra 原理
4. HBase 原理

### 第四阶段：服务治理（3-4 周）
1. 服务注册与发现
2. RPC 框架（Dubbo）
3. 负载均衡
4. 限流熔断降级

### 第五阶段：微服务架构（2-3 周）
1. Spring Cloud 全家桶
2. 分布式事务
3. 链路追踪
4. 配置中心

### 第六阶段：实战项目（持续）
1. 搭建微服务架构
2. 实现分布式锁
3. 实现 ID 生成器
4. 解决实际问题

## 推荐学习资源

### 书籍
- 《分布式系统原理与范型》 - Andrew S. Tanenbaum
- 《数据密集型应用系统设计》（DDIA） - Martin Kleppmann
- 《深入理解分布式系统》 - 陈现麟

### 论文
- Paxos Made Simple - Leslie Lamport
- In Search of an Understandable Consensus Algorithm (Raft) - Diego Ongaro
- Dynamo: Amazon's Highly Available Key-value Store

### 博客文章
- Raft 动画演示：https://raft.github.io/
- 分布式系统领域经典论文
- 阿里技术博客

### 开源项目
- [etcd](https://github.com/etcd-io/etcd) - Raft 实现
- [ZooKeeper](https://github.com/apache/zookeeper) - ZAB 实现
- [Spring Cloud](https://github.com/spring-cloud) - 微服务全家桶
- [Dubbo](https://github.com/apache/dubbo) - RPC 框架

## 学习建议

### 1. 理论与实践结合
- 阅读论文理解算法原理
- 看动画演示加深理解
- 动手实现核心算法
- 部署开源项目验证

### 2. 画图理解
- 画出 Raft 选举和日志复制流程
- 画出一致性哈希环
- 画出微服务调用链路
- 画出各种架构图

### 3. 源码阅读
推荐阅读顺序：
1. etcd 的 Raft 实现
2. ZooKeeper 的 ZAB 实现
3. Dubbo 的服务治理实现
4. Sentinel 的限流熔断实现

### 4. 真实案例分析
- 分析大厂的分布式系统架构
- 研究开源项目的设计决策
- 总结生产环境的经验教训

---

**预计总学习时间**：12-16 周

**重点章节**：
- 一致性算法（Raft）
- 分布式事务
- 服务治理与限流熔断

**学习建议**：
1. Raft 算法是重中之重，务必彻底理解
2. 动手实践：部署 ZooKeeper、etcd、Dubbo
3. 阅读经典论文和开源代码
4. 关注大厂技术博客和分享

掌握分布式系统，是成为高级工程师的必经之路！
